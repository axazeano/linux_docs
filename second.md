# Вторая часть
Содержание:

 1. Просмотр текстовых файлов
 2. Редактирование текстовых файлов
 3. Apt
 
<hr>
<hr>

### Просмотр текстовых файлов
Существует несколько утилит для просмотра текстовых файлов в консоли, такие как `cat`, `less`, и немного специфичные `head`, `tail`. Давай посмотрим на них подробнее:
#### :heavy_plus_sign: `cat`
Название этой утилиты не имеет ничего общего с котами и кошками и является сокращением от concatenate (конкатенация). При помощи этой утилиты можно конкатенировать файлы. Воу воу, что же такое **конкатенация**? Давайте обратимся к википедии:

> Конкатена́ция (лат. concatenatio «присоединение цепями; сцепле́ние») — операция склеивания объектов линейной структуры, обычно строк. Например, конкатенация слов «микро» и «мир» даст слово «микромир».

Строка - объект линейной структуры??? Ну, да, в терминах многих языков программирования строка представляет собой одномерный массив с символами. Массив (**Array** на английском), на всякий случай, представляет собой множество однотипных элементов, как, например, дома на улице. Каждый дом похож друг на друга и имеет порядковый номер:

`array = [дом1, дом2, дом3, ...]`

Строка (Обычно, **String** на английском) `привет!` будет содержать символы:

`string_hello = ['п', 'р', 'и', 'в', 'е', 'т', '!',]` 

Допустим, у нас есть ещё одна строка c текстом `Вася, `:

`string_vasya = ['В', 'а', 'с', 'я', ',', ' ', ]`

Давай проведём конкатенацию этих строк!

`string_vasya + string_hello`

Получится строка `Вася, привет!`

Что произошло при сложении строк? Общими словами была создана новая строка (массив с символами) размером в 13 символов, в которую в начале поместили символы первой строки, затем символы второй строки. Почему 13? Потому что это минимальное число символов, которое сможет уместить в себя обе строки (`привет!` - 7 символов,  `Вася, ` - 6 символов).

Запутанно, и как это связано с чтением файлов? Давайте глянем в `man cat`:

![man cat](imgs/man_cat.png)

Утилита `cat` не только конкатенирует файлы, но и печатает их на консоль, чем собственно мы и воспользуемся. Если мы передадим всего один файл в эту утилиту, то она просто напечатает его на экране (и впрямь, конкатенировать его ведь не с чем):
![cat first example](imgs/cat_first_example.png)

Давай попробуем объединить два файла и вывести их на экран:
![cat second example](imgs/cat_second_example.png)

<hr>

### :arrow_down_small: `head`

![how head works](imgs/how_head_works.png)

Эта утилита выводит несколько первых строк из файла. Просто и удобно. Зачем это нужно, скажешь ты? Допустим, у нас есть файл, причем файл довольно объемный, мегабайт так на 50. При помощи `cat` его не просмотришь, он просто не влезет в консоль (да да, вывод в консоль ограничивается некоторым числом строк, число выставляется в настройках эмулятора терминала) и будет показан только его конец.


> Настройка числа строк в iTerm 2. Есть опция неограниченного числа строк (unlimited srollback), но в нашем случае это не панацея

>![iTerm2 scrollback lines settings](imgs/scrollback_lines.png)


Давай попробуем `head` в деле. Для начала сделаем файл с несколькими строками:
![create multilines file](imgs/create_multilines_file.png)

Вначале объединим два наших файла и вывод утилиты `cat` направим в новый файл. Затем добавим новую строку при помощи команды `echo`.

Проверим содержимое файла:

![check multilines file](imgs/check_multilines_file.png)

Затем глянем в `man head`:

![create multilines file](imgs/man_head.png)

<hr>

#### Мини-раздел "читаем документацию в `man`"

Очень важно научиться читать документацию. Да, она на английском языке, поэтому вооружаемся словариками. Пройдемся по разделам и попробуем понять, что же из себя представляет такая простая6 с виду, утилита `head`:

**NAME**

Приведено название команды и что она в принципе делает. Вольный перевод:

`head --отоборажает первые строки файла`

**SYNOPSIS**

Синопсис содержит в себе информацию о том, как можно использовать команду. Синопсис утилиты `head` выглядит следующим образом:

`head [-n count | -c bytes] [file ...]`

Как это понимать? Для начала взглянем на то, что он разделён на блоки:
- `head` - имя утилиты
- `[-n count | -c bytes]` - флаги с параметрами
- `[file ...]` - основные параметры утилиты
 
Давайте попробуем разобраться что к чему. С первым блоком должно быть все понятно. 
 
Второй блок заключен в квадратные скобки. Что это значит? Квадратные скобки означают то, **что находиться в них является необязательным**!. Мы можем вызвать команду без этого блока.
 
С квадратными скобками мы разобрались и можем их опустить. Теперь можно представить второй блока как `-n count | -c bytes`. Как было уже сказанно выше, этот блок содержит флаги. Флаги обычно начинаются со знака - и позволяют передать утилите дополнительные параметры. Здесь есть два флага:
 
- `-n count` - устанавливаем количество выводимых строк (как мы помним, `head` выводит несколько первых строк файла)
- `-c bytes` - устанавливает количество выводимых байт (например, мы хотим вывести первые 1024 байта, иногда полезно)
 
Как можно заметить, флаги разделяет символ вертикальной черты **|** . Данный символ принято читать как **ИЛИ** . Мы выводим несколько строк **ИЛИ** некоторое количество байт, но вместе эти параметры использовать нельзя.
 
Взглянем на поледний блок `[file ..]`. Внутри него можно передать файл или несколько файлов, из которых будут выведены первые строки. По квадратным скобкам становится ясно, что он тоже не обязателен к написанию. Но как же так, если мы не напишем из какого файла выводить строки, что же будет??? Читаем документацию дальше
 
 **Description**
 
 Тут уже идет нормальная, человекочитаемая документация на английском языке. 
 
`This filter displays are the first count lines or bytes for each of the specified files, or of the standart input if no files are specified` - Этот фильтр отображает заданное число первых строк или байт из каждого указанного файла или использует стандартный поток ввода если файлы не заданы.
 
Как видно, `head` назвали **фильтром**. При помощи него можно фильтровать информацию в так называемых пайплайнах (`pipe-line`) или как их ещё называют конвеерах. Это отдельная глава, сейчас мы коснёмся её лишь вскользь. И так же мы поняли, что если мы не укажем третий блок с файлами, то утилита `head` будет брать информацию из `stdin`. 

`If count is omitted it defaults to 10.` - Если число строк не указано, будет использованно значение по-умолчанию равное 10. 
Ага, если мы пропускаем второй блок, и не указываем число строк или число байт, то по-умолчанию выводятся первые десять строк.

`If more than a single file is specified, each file is preceded by a header consisting of the string ``==> XXX <=='' where ``XXX'' is the name of the file.` - Если указанно более одного файла, каждый файл будет начинаться со строки вида `==> XXX <==`, где `XXX` - имя файла. Ну, сделанно это явно для удобства.

![head_multifiles](imgs/head_multifile.png)

**EXIT STATUS**

`Exit Status` - число, которое возвращает утилита по завершению своей работы. По этому числу можно определить, закончила ли программа работу корректно, или случилась какая-то ошибка.

`The head utility exits 0 on success, and >0 if an error occurs.` - Утилита `head` возвращает `0` в случае успешного завершения работы и число большее нуля в случае возникновения ошибок.

 **SEE ALSO**
 Схожие по функционалу утилиты. В данном случае приведена утилита `tail`
 
 **HISTORY**
 История утилиты
 
 Прочёв документацию можно начать пользоваться утилитой `head`:
 - `head -n 5 foo` - читаем 5 первых строк из файла `foo`
 - `head -b 2048 foo` - читаем 2048 байт из файла `foo`
 - `head foo` - читаем 10 (по-умолчанию) строк из `foo` 
 - `cat my_big_file | head -n 20` - это один из примеров использования конвеера. Не дай себя запутать, если ты читал про стандартные потоки, то знаешь что тут символ прямой линии **|** связывает выходной поток предшествующей ему программы с входным потоком следующим за ним программы. В данном случае в начале мы читаем большой файл `my_big_file` при помощи утилиты `cat` и направляем выходной поток не в консоль для вывода текста, а соединяем его с входным потоком утилиты `head` (заметь, мы вызвали `head` без указания файла). В данном случае в `head` попадает текст из утилиты `cat`, `head` берёт из него 20 первых строк и выводит на экран
 
 <hr>
